/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : ./StreamSQL.g
 *     -                            On : 2023-02-15 17:42:06
 *     -                for the parser : StreamSQLParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "StreamSQLParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pStreamSQLParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pStreamSQLParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pStreamSQLParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pStreamSQLParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   StreamSQLParserTokenNames[39+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "Digit",
        (pANTLR3_UINT8) "Exponent",
        (pANTLR3_UINT8) "Identifier",
        (pANTLR3_UINT8) "KW_ADVANCE",
        (pANTLR3_UINT8) "KW_AS",
        (pANTLR3_UINT8) "KW_CREATE",
        (pANTLR3_UINT8) "KW_DOUBLE",
        (pANTLR3_UINT8) "KW_FROM",
        (pANTLR3_UINT8) "KW_INPUT",
        (pANTLR3_UINT8) "KW_INT",
        (pANTLR3_UINT8) "KW_INTO",
        (pANTLR3_UINT8) "KW_ON",
        (pANTLR3_UINT8) "KW_OUTPUT",
        (pANTLR3_UINT8) "KW_SCHEMA",
        (pANTLR3_UINT8) "KW_SELECT",
        (pANTLR3_UINT8) "KW_SIZE",
        (pANTLR3_UINT8) "KW_STREAM",
        (pANTLR3_UINT8) "KW_WINDOW",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "LSQUARE",
        (pANTLR3_UINT8) "Letter",
        (pANTLR3_UINT8) "MINUS",
        (pANTLR3_UINT8) "Number",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "RSQUARE",
        (pANTLR3_UINT8) "SEMICOLON",
        (pANTLR3_UINT8) "TOK_CREATE_SCHEMA",
        (pANTLR3_UINT8) "TOK_CREATE_STREAM",
        (pANTLR3_UINT8) "TOK_CREATE_WINDOW",
        (pANTLR3_UINT8) "TOK_NAME_TYPE",
        (pANTLR3_UINT8) "TOK_SCHEMA_LIST",
        (pANTLR3_UINT8) "TOK_SELECT",
        (pANTLR3_UINT8) "TOK_SELEXPR",
        (pANTLR3_UINT8) "TOK_SELITEM",
        (pANTLR3_UINT8) "TOK_SELLIST",
        (pANTLR3_UINT8) "WS"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 StreamSQLParser_statement_return
	statement    (pStreamSQLParser ctx);
static 
 StreamSQLParser_selectStatement_return
	selectStatement    (pStreamSQLParser ctx);
static 
 StreamSQLParser_selectList_return
	selectList    (pStreamSQLParser ctx);
static 
 StreamSQLParser_selectColumn_return
	selectColumn    (pStreamSQLParser ctx);
static 
 StreamSQLParser_selectItem_return
	selectItem    (pStreamSQLParser ctx);
static 
 StreamSQLParser_selectExpression_return
	selectExpression    (pStreamSQLParser ctx);
static 
 StreamSQLParser_createStatement_return
	createStatement    (pStreamSQLParser ctx);
static 
 StreamSQLParser_schemaList_return
	schemaList    (pStreamSQLParser ctx);
static 
 StreamSQLParser_streamType_return
	streamType    (pStreamSQLParser ctx);
static 
 StreamSQLParser_columnNameType_return
	columnNameType    (pStreamSQLParser ctx);
static 
 StreamSQLParser_dataType_return
	dataType    (pStreamSQLParser ctx);
static void	StreamSQLParserFree(pStreamSQLParser ctx);
static void     StreamSQLParserReset (pStreamSQLParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "./StreamSQL.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new StreamSQLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pStreamSQLParser
StreamSQLParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return StreamSQLParserNewSSD(instream, NULL);
}

/** \brief Create a new StreamSQLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pStreamSQLParser
StreamSQLParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pStreamSQLParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pStreamSQLParser) ANTLR3_CALLOC(1, sizeof(StreamSQLParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in StreamSQLParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our StreamSQLParser interface
     */
    ctx->statement	= statement;
    ctx->selectStatement	= selectStatement;
    ctx->selectList	= selectList;
    ctx->selectColumn	= selectColumn;
    ctx->selectItem	= selectItem;
    ctx->selectExpression	= selectExpression;
    ctx->createStatement	= createStatement;
    ctx->schemaList	= schemaList;
    ctx->streamType	= streamType;
    ctx->columnNameType	= columnNameType;
    ctx->dataType	= dataType;
    ctx->free			= StreamSQLParserFree;
    ctx->reset			= StreamSQLParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);

ctx->vectors	= antlr3VectorFactoryNew(0);
    /* Install the token table
     */
    PSRSTATE->tokenNames   = StreamSQLParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
StreamSQLParserReset (pStreamSQLParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 StreamSQLParserFree(pStreamSQLParser ctx)
 {
    /* Free any scope memory
     */

ctx->vectors->close(ctx->vectors);
/* We created the adaptor so we must free it
 */
ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return StreamSQLParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectStatement_in_statement123  */
static	ANTLR3_BITWORD FOLLOW_selectStatement_in_statement123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_selectStatement_in_statement123	= { FOLLOW_selectStatement_in_statement123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_statement125  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_statement125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_statement125	= { FOLLOW_EOF_in_statement125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_createStatement_in_statement134  */
static	ANTLR3_BITWORD FOLLOW_createStatement_in_statement134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_createStatement_in_statement134	= { FOLLOW_createStatement_in_statement134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_statement136  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_statement136_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_statement136	= { FOLLOW_EOF_in_statement136_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_SELECT_in_selectStatement155  */
static	ANTLR3_BITWORD FOLLOW_KW_SELECT_in_selectStatement155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_SELECT_in_selectStatement155	= { FOLLOW_KW_SELECT_in_selectStatement155_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectList_in_selectStatement157  */
static	ANTLR3_BITWORD FOLLOW_selectList_in_selectStatement157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_selectList_in_selectStatement157	= { FOLLOW_selectList_in_selectStatement157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_FROM_in_selectStatement167  */
static	ANTLR3_BITWORD FOLLOW_KW_FROM_in_selectStatement167_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_FROM_in_selectStatement167	= { FOLLOW_KW_FROM_in_selectStatement167_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectStatement171  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectStatement171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectStatement171	= { FOLLOW_Identifier_in_selectStatement171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LSQUARE_in_selectStatement173  */
static	ANTLR3_BITWORD FOLLOW_LSQUARE_in_selectStatement173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_LSQUARE_in_selectStatement173	= { FOLLOW_LSQUARE_in_selectStatement173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectStatement177  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectStatement177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectStatement177	= { FOLLOW_Identifier_in_selectStatement177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RSQUARE_in_selectStatement179  */
static	ANTLR3_BITWORD FOLLOW_RSQUARE_in_selectStatement179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_RSQUARE_in_selectStatement179	= { FOLLOW_RSQUARE_in_selectStatement179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_INTO_in_selectStatement181  */
static	ANTLR3_BITWORD FOLLOW_KW_INTO_in_selectStatement181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_INTO_in_selectStatement181	= { FOLLOW_KW_INTO_in_selectStatement181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectStatement185  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectStatement185_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectStatement185	= { FOLLOW_Identifier_in_selectStatement185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectColumn_in_selectList229  */
static	ANTLR3_BITWORD FOLLOW_selectColumn_in_selectList229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_selectColumn_in_selectList229	= { FOLLOW_selectColumn_in_selectList229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_selectList232  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_selectList232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_selectList232	= { FOLLOW_COMMA_in_selectList232_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectColumn_in_selectList234  */
static	ANTLR3_BITWORD FOLLOW_selectColumn_in_selectList234_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_selectColumn_in_selectList234	= { FOLLOW_selectColumn_in_selectList234_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectItem_in_selectColumn272  */
static	ANTLR3_BITWORD FOLLOW_selectItem_in_selectColumn272_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_selectItem_in_selectColumn272	= { FOLLOW_selectItem_in_selectColumn272_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectExpression_in_selectColumn281  */
static	ANTLR3_BITWORD FOLLOW_selectExpression_in_selectColumn281_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_selectExpression_in_selectColumn281	= { FOLLOW_selectExpression_in_selectColumn281_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectItem302  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectItem302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectItem302	= { FOLLOW_Identifier_in_selectItem302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_AS_in_selectItem304  */
static	ANTLR3_BITWORD FOLLOW_KW_AS_in_selectItem304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_AS_in_selectItem304	= { FOLLOW_KW_AS_in_selectItem304_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectItem306  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectItem306_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectItem306	= { FOLLOW_Identifier_in_selectItem306_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectExpression345  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectExpression345_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectExpression345	= { FOLLOW_Identifier_in_selectExpression345_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_selectExpression347  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_selectExpression347_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_selectExpression347	= { FOLLOW_LPAREN_in_selectExpression347_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectExpression351  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectExpression351_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectExpression351	= { FOLLOW_Identifier_in_selectExpression351_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_selectExpression353  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_selectExpression353_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_selectExpression353	= { FOLLOW_RPAREN_in_selectExpression353_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_AS_in_selectExpression355  */
static	ANTLR3_BITWORD FOLLOW_KW_AS_in_selectExpression355_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_AS_in_selectExpression355	= { FOLLOW_KW_AS_in_selectExpression355_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectExpression359  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectExpression359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectExpression359	= { FOLLOW_Identifier_in_selectExpression359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_CREATE_in_createStatement401  */
static	ANTLR3_BITWORD FOLLOW_KW_CREATE_in_createStatement401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_CREATE_in_createStatement401	= { FOLLOW_KW_CREATE_in_createStatement401_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_SCHEMA_in_createStatement403  */
static	ANTLR3_BITWORD FOLLOW_KW_SCHEMA_in_createStatement403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_SCHEMA_in_createStatement403	= { FOLLOW_KW_SCHEMA_in_createStatement403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_createStatement405  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_createStatement405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_createStatement405	= { FOLLOW_Identifier_in_createStatement405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_schemaList_in_createStatement407  */
static	ANTLR3_BITWORD FOLLOW_schemaList_in_createStatement407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_schemaList_in_createStatement407	= { FOLLOW_schemaList_in_createStatement407_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_CREATE_in_createStatement439  */
static	ANTLR3_BITWORD FOLLOW_KW_CREATE_in_createStatement439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000044000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_CREATE_in_createStatement439	= { FOLLOW_KW_CREATE_in_createStatement439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_streamType_in_createStatement441  */
static	ANTLR3_BITWORD FOLLOW_streamType_in_createStatement441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_streamType_in_createStatement441	= { FOLLOW_streamType_in_createStatement441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_STREAM_in_createStatement443  */
static	ANTLR3_BITWORD FOLLOW_KW_STREAM_in_createStatement443_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_STREAM_in_createStatement443	= { FOLLOW_KW_STREAM_in_createStatement443_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_createStatement447  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_createStatement447_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_createStatement447	= { FOLLOW_Identifier_in_createStatement447_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_createStatement451  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_createStatement451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_createStatement451	= { FOLLOW_Identifier_in_createStatement451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_CREATE_in_createStatement482  */
static	ANTLR3_BITWORD FOLLOW_KW_CREATE_in_createStatement482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_CREATE_in_createStatement482	= { FOLLOW_KW_CREATE_in_createStatement482_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_WINDOW_in_createStatement484  */
static	ANTLR3_BITWORD FOLLOW_KW_WINDOW_in_createStatement484_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_WINDOW_in_createStatement484	= { FOLLOW_KW_WINDOW_in_createStatement484_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_createStatement496  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_createStatement496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_createStatement496	= { FOLLOW_Identifier_in_createStatement496_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_createStatement498  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_createStatement498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_createStatement498	= { FOLLOW_LPAREN_in_createStatement498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_SIZE_in_createStatement500  */
static	ANTLR3_BITWORD FOLLOW_KW_SIZE_in_createStatement500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_SIZE_in_createStatement500	= { FOLLOW_KW_SIZE_in_createStatement500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Number_in_createStatement502  */
static	ANTLR3_BITWORD FOLLOW_Number_in_createStatement502_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_Number_in_createStatement502	= { FOLLOW_Number_in_createStatement502_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_ADVANCE_in_createStatement504  */
static	ANTLR3_BITWORD FOLLOW_KW_ADVANCE_in_createStatement504_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_ADVANCE_in_createStatement504	= { FOLLOW_KW_ADVANCE_in_createStatement504_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Number_in_createStatement506  */
static	ANTLR3_BITWORD FOLLOW_Number_in_createStatement506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_Number_in_createStatement506	= { FOLLOW_Number_in_createStatement506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_ON_in_createStatement508  */
static	ANTLR3_BITWORD FOLLOW_KW_ON_in_createStatement508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_ON_in_createStatement508	= { FOLLOW_KW_ON_in_createStatement508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_createStatement512  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_createStatement512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_createStatement512	= { FOLLOW_Identifier_in_createStatement512_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_createStatement514  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_createStatement514_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_createStatement514	= { FOLLOW_RPAREN_in_createStatement514_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_schemaList557  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_schemaList557_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_schemaList557	= { FOLLOW_LPAREN_in_schemaList557_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_columnNameType_in_schemaList559  */
static	ANTLR3_BITWORD FOLLOW_columnNameType_in_schemaList559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000010) };
static  ANTLR3_BITSET_LIST FOLLOW_columnNameType_in_schemaList559	= { FOLLOW_columnNameType_in_schemaList559_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_schemaList562  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_schemaList562_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_schemaList562	= { FOLLOW_COMMA_in_schemaList562_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_columnNameType_in_schemaList564  */
static	ANTLR3_BITWORD FOLLOW_columnNameType_in_schemaList564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000010) };
static  ANTLR3_BITSET_LIST FOLLOW_columnNameType_in_schemaList564	= { FOLLOW_columnNameType_in_schemaList564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_schemaList568  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_schemaList568_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_schemaList568	= { FOLLOW_RPAREN_in_schemaList568_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_columnNameType631  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_columnNameType631_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000009000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_columnNameType631	= { FOLLOW_Identifier_in_columnNameType631_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dataType_in_columnNameType633  */
static	ANTLR3_BITWORD FOLLOW_dataType_in_columnNameType633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dataType_in_columnNameType633	= { FOLLOW_dataType_in_columnNameType633_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start statement
 * ./StreamSQL.g:35:1: statement : ( selectStatement EOF | createStatement EOF );
 */
static StreamSQLParser_statement_return
statement(pStreamSQLParser ctx)
{
    StreamSQLParser_statement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EOF2;
    pANTLR3_COMMON_TOKEN    EOF4;
    StreamSQLParser_selectStatement_return selectStatement1;
    #undef	RETURN_TYPE_selectStatement1
    #define	RETURN_TYPE_selectStatement1 StreamSQLParser_selectStatement_return

    StreamSQLParser_createStatement_return createStatement3;
    #undef	RETURN_TYPE_createStatement3
    #define	RETURN_TYPE_createStatement3 StreamSQLParser_createStatement_return

    pANTLR3_BASE_TREE EOF2_tree;
    pANTLR3_BASE_TREE EOF4_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EOF2       = NULL;
    EOF4       = NULL;
    selectStatement1.tree = NULL;

    createStatement3.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EOF2_tree   = NULL;
    EOF4_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  ./StreamSQL.g:37:5: ( selectStatement EOF | createStatement EOF )

            ANTLR3_UINT32 alt1;

            alt1=2;

            switch ( LA(1) )
            {
            case KW_SELECT:
            	{
            		alt1=1;
            	}
                break;
            case KW_CREATE:
            	{
            		alt1=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto rulestatementEx;

            }

            switch (alt1)
            {
        	case 1:
        	    // ./StreamSQL.g:37:7: selectStatement EOF
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_selectStatement_in_statement123);
        	        selectStatement1=selectStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, selectStatement1.tree);

        	        EOF2 = (pANTLR3_COMMON_TOKEN) MATCHT(EOF, &FOLLOW_EOF_in_statement125);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        EOF2_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EOF2));
        	        ADAPTOR->addChild(ADAPTOR, root_0, EOF2_tree);


        	    }
        	    break;
        	case 2:
        	    // ./StreamSQL.g:39:7: createStatement EOF
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_createStatement_in_statement134);
        	        createStatement3=createStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, createStatement3.tree);

        	        EOF4 = (pANTLR3_COMMON_TOKEN) MATCHT(EOF, &FOLLOW_EOF_in_statement136);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        EOF4_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EOF4));
        	        ADAPTOR->addChild(ADAPTOR, root_0, EOF4_tree);


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end statement */

/**
 * $ANTLR start selectStatement
 * ./StreamSQL.g:43:1: selectStatement : KW_SELECT selectList KW_FROM instreamName= Identifier LSQUARE windowName= Identifier RSQUARE KW_INTO outstreamName= Identifier -> ^( KW_SELECT selectList $instreamName $windowName $outstreamName) ;
 */
static StreamSQLParser_selectStatement_return
selectStatement(pStreamSQLParser ctx)
{
    StreamSQLParser_selectStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    instreamName;
    pANTLR3_COMMON_TOKEN    windowName;
    pANTLR3_COMMON_TOKEN    outstreamName;
    pANTLR3_COMMON_TOKEN    KW_SELECT5;
    pANTLR3_COMMON_TOKEN    KW_FROM7;
    pANTLR3_COMMON_TOKEN    LSQUARE8;
    pANTLR3_COMMON_TOKEN    RSQUARE9;
    pANTLR3_COMMON_TOKEN    KW_INTO10;
    StreamSQLParser_selectList_return selectList6;
    #undef	RETURN_TYPE_selectList6
    #define	RETURN_TYPE_selectList6 StreamSQLParser_selectList_return

    pANTLR3_BASE_TREE instreamName_tree;
    pANTLR3_BASE_TREE windowName_tree;
    pANTLR3_BASE_TREE outstreamName_tree;
    pANTLR3_BASE_TREE KW_SELECT5_tree;
    pANTLR3_BASE_TREE KW_FROM7_tree;
    pANTLR3_BASE_TREE LSQUARE8_tree;
    pANTLR3_BASE_TREE RSQUARE9_tree;
    pANTLR3_BASE_TREE KW_INTO10_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LSQUARE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_RSQUARE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Identifier;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_INTO;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_FROM;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_SELECT;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_selectList;
    /* Initialize rule variables
     */

    root_0 = NULL;

    instreamName       = NULL;
    windowName       = NULL;
    outstreamName       = NULL;
    KW_SELECT5       = NULL;
    KW_FROM7       = NULL;
    LSQUARE8       = NULL;
    RSQUARE9       = NULL;
    KW_INTO10       = NULL;
    selectList6.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    instreamName_tree   = NULL;
    windowName_tree   = NULL;
    outstreamName_tree   = NULL;
    KW_SELECT5_tree   = NULL;
    KW_FROM7_tree   = NULL;
    LSQUARE8_tree   = NULL;
    RSQUARE9_tree   = NULL;
    KW_INTO10_tree   = NULL;

    stream_LSQUARE   = NULL;
    #define CREATE_stream_LSQUARE  if (stream_LSQUARE == NULL) {stream_LSQUARE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LSQUARE"); } 
    stream_RSQUARE   = NULL;
    #define CREATE_stream_RSQUARE  if (stream_RSQUARE == NULL) {stream_RSQUARE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token RSQUARE"); } 
    stream_Identifier   = NULL;
    #define CREATE_stream_Identifier  if (stream_Identifier == NULL) {stream_Identifier = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Identifier"); } 
    stream_KW_INTO   = NULL;
    #define CREATE_stream_KW_INTO  if (stream_KW_INTO == NULL) {stream_KW_INTO = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_INTO"); } 
    stream_KW_FROM   = NULL;
    #define CREATE_stream_KW_FROM  if (stream_KW_FROM == NULL) {stream_KW_FROM = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_FROM"); } 
    stream_KW_SELECT   = NULL;
    #define CREATE_stream_KW_SELECT  if (stream_KW_SELECT == NULL) {stream_KW_SELECT = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_SELECT"); } 
    stream_selectList   = NULL;
    #define CREATE_stream_selectList  if (stream_selectList == NULL) {stream_selectList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule selectList"); }

    retval.tree  = NULL;

    {
        // ./StreamSQL.g:45:5: ( KW_SELECT selectList KW_FROM instreamName= Identifier LSQUARE windowName= Identifier RSQUARE KW_INTO outstreamName= Identifier -> ^( KW_SELECT selectList $instreamName $windowName $outstreamName) )
        // ./StreamSQL.g:45:7: KW_SELECT selectList KW_FROM instreamName= Identifier LSQUARE windowName= Identifier RSQUARE KW_INTO outstreamName= Identifier
        {
            KW_SELECT5 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_SELECT, &FOLLOW_KW_SELECT_in_selectStatement155);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_KW_SELECT; stream_KW_SELECT->add(stream_KW_SELECT, KW_SELECT5, NULL);


            FOLLOWPUSH(FOLLOW_selectList_in_selectStatement157);
            selectList6=selectList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }

            CREATE_stream_selectList; stream_selectList->add(stream_selectList, selectList6.tree, NULL);

            KW_FROM7 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_FROM, &FOLLOW_KW_FROM_in_selectStatement167);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_KW_FROM; stream_KW_FROM->add(stream_KW_FROM, KW_FROM7, NULL);


            instreamName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectStatement171);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, instreamName, NULL);


            LSQUARE8 = (pANTLR3_COMMON_TOKEN) MATCHT(LSQUARE, &FOLLOW_LSQUARE_in_selectStatement173);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_LSQUARE; stream_LSQUARE->add(stream_LSQUARE, LSQUARE8, NULL);


            windowName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectStatement177);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, windowName, NULL);


            RSQUARE9 = (pANTLR3_COMMON_TOKEN) MATCHT(RSQUARE, &FOLLOW_RSQUARE_in_selectStatement179);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_RSQUARE; stream_RSQUARE->add(stream_RSQUARE, RSQUARE9, NULL);


            KW_INTO10 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_INTO, &FOLLOW_KW_INTO_in_selectStatement181);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_KW_INTO; stream_KW_INTO->add(stream_KW_INTO, KW_INTO10, NULL);


            outstreamName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectStatement185);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, outstreamName, NULL);


            /* AST REWRITE
             * elements          : outstreamName, KW_SELECT, instreamName, windowName, selectList
             * token labels      : instreamName, windowName, outstreamName
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_instreamName;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_windowName;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_outstreamName;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_instreamName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token instreamName", instreamName);
            	stream_windowName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token windowName", windowName);
            	stream_outstreamName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token outstreamName", outstreamName);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 49:8: -> ^( KW_SELECT selectList $instreamName $windowName $outstreamName)
            	{
            	    // ./StreamSQL.g:49:11: ^( KW_SELECT selectList $instreamName $windowName $outstreamName)
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        stream_KW_SELECT == NULL ? NULL : stream_KW_SELECT->nextNode(stream_KW_SELECT)
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_selectList == NULL ? NULL : stream_selectList->nextTree(stream_selectList));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instreamName == NULL ? NULL : stream_instreamName->nextNode(stream_instreamName));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_windowName == NULL ? NULL : stream_windowName->nextNode(stream_windowName));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_outstreamName == NULL ? NULL : stream_outstreamName->nextNode(stream_outstreamName));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_instreamName != NULL) stream_instreamName->free(stream_instreamName); 
            	if (stream_windowName != NULL) stream_windowName->free(stream_windowName); 
            	if (stream_outstreamName != NULL) stream_outstreamName->free(stream_outstreamName); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleselectStatementEx; /* Prevent compiler warnings */
    ruleselectStatementEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_LSQUARE != NULL) stream_LSQUARE->free(stream_LSQUARE);
        if (stream_RSQUARE != NULL) stream_RSQUARE->free(stream_RSQUARE);
        if (stream_Identifier != NULL) stream_Identifier->free(stream_Identifier);
        if (stream_KW_INTO != NULL) stream_KW_INTO->free(stream_KW_INTO);
        if (stream_KW_FROM != NULL) stream_KW_FROM->free(stream_KW_FROM);
        if (stream_KW_SELECT != NULL) stream_KW_SELECT->free(stream_KW_SELECT);
        if (stream_selectList != NULL) stream_selectList->free(stream_selectList);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end selectStatement */

/**
 * $ANTLR start selectList
 * ./StreamSQL.g:53:1: selectList : selectColumn ( COMMA selectColumn )* -> ^( TOK_SELLIST ( selectColumn )+ ) ;
 */
static StreamSQLParser_selectList_return
selectList(pStreamSQLParser ctx)
{
    StreamSQLParser_selectList_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA12;
    StreamSQLParser_selectColumn_return selectColumn11;
    #undef	RETURN_TYPE_selectColumn11
    #define	RETURN_TYPE_selectColumn11 StreamSQLParser_selectColumn_return

    StreamSQLParser_selectColumn_return selectColumn13;
    #undef	RETURN_TYPE_selectColumn13
    #define	RETURN_TYPE_selectColumn13 StreamSQLParser_selectColumn_return

    pANTLR3_BASE_TREE COMMA12_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_COMMA;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_selectColumn;
    /* Initialize rule variables
     */

    root_0 = NULL;

    COMMA12       = NULL;
    selectColumn11.tree = NULL;

    selectColumn13.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    COMMA12_tree   = NULL;

    stream_COMMA   = NULL;
    #define CREATE_stream_COMMA  if (stream_COMMA == NULL) {stream_COMMA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token COMMA"); } 
    stream_selectColumn   = NULL;
    #define CREATE_stream_selectColumn  if (stream_selectColumn == NULL) {stream_selectColumn = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule selectColumn"); }

    retval.tree  = NULL;

    {
        // ./StreamSQL.g:55:5: ( selectColumn ( COMMA selectColumn )* -> ^( TOK_SELLIST ( selectColumn )+ ) )
        // ./StreamSQL.g:55:7: selectColumn ( COMMA selectColumn )*
        {
            FOLLOWPUSH(FOLLOW_selectColumn_in_selectList229);
            selectColumn11=selectColumn(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectListEx;
            }

            CREATE_stream_selectColumn; stream_selectColumn->add(stream_selectColumn, selectColumn11.tree, NULL);

            // ./StreamSQL.g:55:20: ( COMMA selectColumn )*

            for (;;)
            {
                int alt2=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		alt2=1;
                	}
                    break;

                }

                switch (alt2)
                {
            	case 1:
            	    // ./StreamSQL.g:55:21: COMMA selectColumn
            	    {
            	        COMMA12 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_selectList232);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleselectListEx;
            	        }
            	         
            	        CREATE_stream_COMMA; stream_COMMA->add(stream_COMMA, COMMA12, NULL);


            	        FOLLOWPUSH(FOLLOW_selectColumn_in_selectList234);
            	        selectColumn13=selectColumn(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleselectListEx;
            	        }

            	        CREATE_stream_selectColumn; stream_selectColumn->add(stream_selectColumn, selectColumn13.tree, NULL);

            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


            /* AST REWRITE
             * elements          : selectColumn
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 57:8: -> ^( TOK_SELLIST ( selectColumn )+ )
            	{
            	    // ./StreamSQL.g:57:11: ^( TOK_SELLIST ( selectColumn )+ )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_SELLIST, (pANTLR3_UINT8)"TOK_SELLIST")
            	        , root_1));

            	        if ((stream_selectColumn == NULL || !stream_selectColumn->hasNext(stream_selectColumn))  )
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
            	        }
            	        else
            	        {
            	        	while ( (stream_selectColumn->hasNext(stream_selectColumn))  ) {
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_selectColumn == NULL ? NULL : stream_selectColumn->nextTree(stream_selectColumn));

            	        	}
            	        	stream_selectColumn->reset(stream_selectColumn);

            	        }
            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleselectListEx; /* Prevent compiler warnings */
    ruleselectListEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_COMMA != NULL) stream_COMMA->free(stream_COMMA);
        if (stream_selectColumn != NULL) stream_selectColumn->free(stream_selectColumn);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end selectList */

/**
 * $ANTLR start selectColumn
 * ./StreamSQL.g:61:1: selectColumn : ( selectItem | selectExpression );
 */
static StreamSQLParser_selectColumn_return
selectColumn(pStreamSQLParser ctx)
{
    StreamSQLParser_selectColumn_return retval;


    pANTLR3_BASE_TREE root_0;

    StreamSQLParser_selectItem_return selectItem14;
    #undef	RETURN_TYPE_selectItem14
    #define	RETURN_TYPE_selectItem14 StreamSQLParser_selectItem_return

    StreamSQLParser_selectExpression_return selectExpression15;
    #undef	RETURN_TYPE_selectExpression15
    #define	RETURN_TYPE_selectExpression15 StreamSQLParser_selectExpression_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    selectItem14.tree = NULL;

    selectExpression15.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  ./StreamSQL.g:63:5: ( selectItem | selectExpression )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case Identifier:
            	{
            		switch ( LA(2) )
            		{
            		case KW_AS:
            			{
            				alt3=1;
            			}
            		    break;
            		case LPAREN:
            			{
            				alt3=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 3;
            		    EXCEPTION->state        = 1;


            		    goto ruleselectColumnEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto ruleselectColumnEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // ./StreamSQL.g:63:7: selectItem
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_selectItem_in_selectColumn272);
        	        selectItem14=selectItem(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleselectColumnEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, selectItem14.tree);

        	    }
        	    break;
        	case 2:
        	    // ./StreamSQL.g:65:7: selectExpression
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_selectExpression_in_selectColumn281);
        	        selectExpression15=selectExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleselectColumnEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, selectExpression15.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleselectColumnEx; /* Prevent compiler warnings */
    ruleselectColumnEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end selectColumn */

/**
 * $ANTLR start selectItem
 * ./StreamSQL.g:69:1: selectItem : Identifier KW_AS Identifier -> ^( TOK_SELITEM Identifier Identifier ) ;
 */
static StreamSQLParser_selectItem_return
selectItem(pStreamSQLParser ctx)
{
    StreamSQLParser_selectItem_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Identifier16;
    pANTLR3_COMMON_TOKEN    KW_AS17;
    pANTLR3_COMMON_TOKEN    Identifier18;

    pANTLR3_BASE_TREE Identifier16_tree;
    pANTLR3_BASE_TREE KW_AS17_tree;
    pANTLR3_BASE_TREE Identifier18_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Identifier;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_AS;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Identifier16       = NULL;
    KW_AS17       = NULL;
    Identifier18       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Identifier16_tree   = NULL;
    KW_AS17_tree   = NULL;
    Identifier18_tree   = NULL;

    stream_Identifier   = NULL;
    #define CREATE_stream_Identifier  if (stream_Identifier == NULL) {stream_Identifier = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Identifier"); } 
    stream_KW_AS   = NULL;
    #define CREATE_stream_KW_AS  if (stream_KW_AS == NULL) {stream_KW_AS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_AS"); } 

    retval.tree  = NULL;

    {
        // ./StreamSQL.g:71:5: ( Identifier KW_AS Identifier -> ^( TOK_SELITEM Identifier Identifier ) )
        // ./StreamSQL.g:71:7: Identifier KW_AS Identifier
        {
            Identifier16 = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectItem302);
            if  (HASEXCEPTION())
            {
                goto ruleselectItemEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, Identifier16, NULL);


            KW_AS17 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_AS, &FOLLOW_KW_AS_in_selectItem304);
            if  (HASEXCEPTION())
            {
                goto ruleselectItemEx;
            }
             
            CREATE_stream_KW_AS; stream_KW_AS->add(stream_KW_AS, KW_AS17, NULL);


            Identifier18 = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectItem306);
            if  (HASEXCEPTION())
            {
                goto ruleselectItemEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, Identifier18, NULL);


            /* AST REWRITE
             * elements          : Identifier, Identifier
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 73:8: -> ^( TOK_SELITEM Identifier Identifier )
            	{
            	    // ./StreamSQL.g:73:11: ^( TOK_SELITEM Identifier Identifier )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_SELITEM, (pANTLR3_UINT8)"TOK_SELITEM")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, 
            	        stream_Identifier == NULL ? NULL : stream_Identifier->nextNode(stream_Identifier)
            	        );

            	        ADAPTOR->addChild(ADAPTOR, root_1, 
            	        stream_Identifier == NULL ? NULL : stream_Identifier->nextNode(stream_Identifier)
            	        );

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleselectItemEx; /* Prevent compiler warnings */
    ruleselectItemEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_Identifier != NULL) stream_Identifier->free(stream_Identifier);
        if (stream_KW_AS != NULL) stream_KW_AS->free(stream_KW_AS);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end selectItem */

/**
 * $ANTLR start selectExpression
 * ./StreamSQL.g:77:1: selectExpression : functionName= Identifier LPAREN itemName= Identifier RPAREN KW_AS asName= Identifier -> ^( TOK_SELEXPR $functionName $itemName $asName) ;
 */
static StreamSQLParser_selectExpression_return
selectExpression(pStreamSQLParser ctx)
{
    StreamSQLParser_selectExpression_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    functionName;
    pANTLR3_COMMON_TOKEN    itemName;
    pANTLR3_COMMON_TOKEN    asName;
    pANTLR3_COMMON_TOKEN    LPAREN19;
    pANTLR3_COMMON_TOKEN    RPAREN20;
    pANTLR3_COMMON_TOKEN    KW_AS21;

    pANTLR3_BASE_TREE functionName_tree;
    pANTLR3_BASE_TREE itemName_tree;
    pANTLR3_BASE_TREE asName_tree;
    pANTLR3_BASE_TREE LPAREN19_tree;
    pANTLR3_BASE_TREE RPAREN20_tree;
    pANTLR3_BASE_TREE KW_AS21_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Identifier;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LPAREN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_RPAREN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_AS;

    /* Initialize rule variables
     */

    root_0 = NULL;

    functionName       = NULL;
    itemName       = NULL;
    asName       = NULL;
    LPAREN19       = NULL;
    RPAREN20       = NULL;
    KW_AS21       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    functionName_tree   = NULL;
    itemName_tree   = NULL;
    asName_tree   = NULL;
    LPAREN19_tree   = NULL;
    RPAREN20_tree   = NULL;
    KW_AS21_tree   = NULL;

    stream_Identifier   = NULL;
    #define CREATE_stream_Identifier  if (stream_Identifier == NULL) {stream_Identifier = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Identifier"); } 
    stream_LPAREN   = NULL;
    #define CREATE_stream_LPAREN  if (stream_LPAREN == NULL) {stream_LPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LPAREN"); } 
    stream_RPAREN   = NULL;
    #define CREATE_stream_RPAREN  if (stream_RPAREN == NULL) {stream_RPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token RPAREN"); } 
    stream_KW_AS   = NULL;
    #define CREATE_stream_KW_AS  if (stream_KW_AS == NULL) {stream_KW_AS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_AS"); } 

    retval.tree  = NULL;

    {
        // ./StreamSQL.g:79:5: (functionName= Identifier LPAREN itemName= Identifier RPAREN KW_AS asName= Identifier -> ^( TOK_SELEXPR $functionName $itemName $asName) )
        // ./StreamSQL.g:79:7: functionName= Identifier LPAREN itemName= Identifier RPAREN KW_AS asName= Identifier
        {
            functionName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectExpression345);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, functionName, NULL);


            LPAREN19 = (pANTLR3_COMMON_TOKEN) MATCHT(LPAREN, &FOLLOW_LPAREN_in_selectExpression347);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_LPAREN; stream_LPAREN->add(stream_LPAREN, LPAREN19, NULL);


            itemName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectExpression351);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, itemName, NULL);


            RPAREN20 = (pANTLR3_COMMON_TOKEN) MATCHT(RPAREN, &FOLLOW_RPAREN_in_selectExpression353);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_RPAREN; stream_RPAREN->add(stream_RPAREN, RPAREN20, NULL);


            KW_AS21 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_AS, &FOLLOW_KW_AS_in_selectExpression355);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_KW_AS; stream_KW_AS->add(stream_KW_AS, KW_AS21, NULL);


            asName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectExpression359);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, asName, NULL);


            /* AST REWRITE
             * elements          : asName, itemName, functionName
             * token labels      : asName, itemName, functionName
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_asName;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_itemName;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_functionName;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_asName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token asName", asName);
            	stream_itemName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token itemName", itemName);
            	stream_functionName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token functionName", functionName);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 81:8: -> ^( TOK_SELEXPR $functionName $itemName $asName)
            	{
            	    // ./StreamSQL.g:81:11: ^( TOK_SELEXPR $functionName $itemName $asName)
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_SELEXPR, (pANTLR3_UINT8)"TOK_SELEXPR")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_functionName == NULL ? NULL : stream_functionName->nextNode(stream_functionName));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_itemName == NULL ? NULL : stream_itemName->nextNode(stream_itemName));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_asName == NULL ? NULL : stream_asName->nextNode(stream_asName));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_asName != NULL) stream_asName->free(stream_asName); 
            	if (stream_itemName != NULL) stream_itemName->free(stream_itemName); 
            	if (stream_functionName != NULL) stream_functionName->free(stream_functionName); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleselectExpressionEx; /* Prevent compiler warnings */
    ruleselectExpressionEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_Identifier != NULL) stream_Identifier->free(stream_Identifier);
        if (stream_LPAREN != NULL) stream_LPAREN->free(stream_LPAREN);
        if (stream_RPAREN != NULL) stream_RPAREN->free(stream_RPAREN);
        if (stream_KW_AS != NULL) stream_KW_AS->free(stream_KW_AS);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end selectExpression */

/**
 * $ANTLR start createStatement
 * ./StreamSQL.g:85:1: createStatement : ( KW_CREATE KW_SCHEMA Identifier schemaList -> ^( TOK_CREATE_SCHEMA Identifier schemaList ) | KW_CREATE streamType KW_STREAM streamName= Identifier schemaName= Identifier -> ^( TOK_CREATE_STREAM streamType $streamName $schemaName) | KW_CREATE KW_WINDOW windowName= Identifier LPAREN KW_SIZE Number KW_ADVANCE Number KW_ON onWhat= Identifier RPAREN -> ^( TOK_CREATE_WINDOW $windowName Number Number $onWhat) );
 */
static StreamSQLParser_createStatement_return
createStatement(pStreamSQLParser ctx)
{
    StreamSQLParser_createStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    streamName;
    pANTLR3_COMMON_TOKEN    schemaName;
    pANTLR3_COMMON_TOKEN    windowName;
    pANTLR3_COMMON_TOKEN    onWhat;
    pANTLR3_COMMON_TOKEN    KW_CREATE22;
    pANTLR3_COMMON_TOKEN    KW_SCHEMA23;
    pANTLR3_COMMON_TOKEN    Identifier24;
    pANTLR3_COMMON_TOKEN    KW_CREATE26;
    pANTLR3_COMMON_TOKEN    KW_STREAM28;
    pANTLR3_COMMON_TOKEN    KW_CREATE29;
    pANTLR3_COMMON_TOKEN    KW_WINDOW30;
    pANTLR3_COMMON_TOKEN    LPAREN31;
    pANTLR3_COMMON_TOKEN    KW_SIZE32;
    pANTLR3_COMMON_TOKEN    Number33;
    pANTLR3_COMMON_TOKEN    KW_ADVANCE34;
    pANTLR3_COMMON_TOKEN    Number35;
    pANTLR3_COMMON_TOKEN    KW_ON36;
    pANTLR3_COMMON_TOKEN    RPAREN37;
    StreamSQLParser_schemaList_return schemaList25;
    #undef	RETURN_TYPE_schemaList25
    #define	RETURN_TYPE_schemaList25 StreamSQLParser_schemaList_return

    StreamSQLParser_streamType_return streamType27;
    #undef	RETURN_TYPE_streamType27
    #define	RETURN_TYPE_streamType27 StreamSQLParser_streamType_return

    pANTLR3_BASE_TREE streamName_tree;
    pANTLR3_BASE_TREE schemaName_tree;
    pANTLR3_BASE_TREE windowName_tree;
    pANTLR3_BASE_TREE onWhat_tree;
    pANTLR3_BASE_TREE KW_CREATE22_tree;
    pANTLR3_BASE_TREE KW_SCHEMA23_tree;
    pANTLR3_BASE_TREE Identifier24_tree;
    pANTLR3_BASE_TREE KW_CREATE26_tree;
    pANTLR3_BASE_TREE KW_STREAM28_tree;
    pANTLR3_BASE_TREE KW_CREATE29_tree;
    pANTLR3_BASE_TREE KW_WINDOW30_tree;
    pANTLR3_BASE_TREE LPAREN31_tree;
    pANTLR3_BASE_TREE KW_SIZE32_tree;
    pANTLR3_BASE_TREE Number33_tree;
    pANTLR3_BASE_TREE KW_ADVANCE34_tree;
    pANTLR3_BASE_TREE Number35_tree;
    pANTLR3_BASE_TREE KW_ON36_tree;
    pANTLR3_BASE_TREE RPAREN37_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_ADVANCE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_SCHEMA;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_WINDOW;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Identifier;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_CREATE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Number;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_STREAM;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LPAREN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_ON;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_RPAREN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_SIZE;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_schemaList;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_streamType;
    /* Initialize rule variables
     */

    root_0 = NULL;

    streamName       = NULL;
    schemaName       = NULL;
    windowName       = NULL;
    onWhat       = NULL;
    KW_CREATE22       = NULL;
    KW_SCHEMA23       = NULL;
    Identifier24       = NULL;
    KW_CREATE26       = NULL;
    KW_STREAM28       = NULL;
    KW_CREATE29       = NULL;
    KW_WINDOW30       = NULL;
    LPAREN31       = NULL;
    KW_SIZE32       = NULL;
    Number33       = NULL;
    KW_ADVANCE34       = NULL;
    Number35       = NULL;
    KW_ON36       = NULL;
    RPAREN37       = NULL;
    schemaList25.tree = NULL;

    streamType27.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    streamName_tree   = NULL;
    schemaName_tree   = NULL;
    windowName_tree   = NULL;
    onWhat_tree   = NULL;
    KW_CREATE22_tree   = NULL;
    KW_SCHEMA23_tree   = NULL;
    Identifier24_tree   = NULL;
    KW_CREATE26_tree   = NULL;
    KW_STREAM28_tree   = NULL;
    KW_CREATE29_tree   = NULL;
    KW_WINDOW30_tree   = NULL;
    LPAREN31_tree   = NULL;
    KW_SIZE32_tree   = NULL;
    Number33_tree   = NULL;
    KW_ADVANCE34_tree   = NULL;
    Number35_tree   = NULL;
    KW_ON36_tree   = NULL;
    RPAREN37_tree   = NULL;

    stream_KW_ADVANCE   = NULL;
    #define CREATE_stream_KW_ADVANCE  if (stream_KW_ADVANCE == NULL) {stream_KW_ADVANCE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_ADVANCE"); } 
    stream_KW_SCHEMA   = NULL;
    #define CREATE_stream_KW_SCHEMA  if (stream_KW_SCHEMA == NULL) {stream_KW_SCHEMA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_SCHEMA"); } 
    stream_KW_WINDOW   = NULL;
    #define CREATE_stream_KW_WINDOW  if (stream_KW_WINDOW == NULL) {stream_KW_WINDOW = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_WINDOW"); } 
    stream_Identifier   = NULL;
    #define CREATE_stream_Identifier  if (stream_Identifier == NULL) {stream_Identifier = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Identifier"); } 
    stream_KW_CREATE   = NULL;
    #define CREATE_stream_KW_CREATE  if (stream_KW_CREATE == NULL) {stream_KW_CREATE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_CREATE"); } 
    stream_Number   = NULL;
    #define CREATE_stream_Number  if (stream_Number == NULL) {stream_Number = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Number"); } 
    stream_KW_STREAM   = NULL;
    #define CREATE_stream_KW_STREAM  if (stream_KW_STREAM == NULL) {stream_KW_STREAM = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_STREAM"); } 
    stream_LPAREN   = NULL;
    #define CREATE_stream_LPAREN  if (stream_LPAREN == NULL) {stream_LPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LPAREN"); } 
    stream_KW_ON   = NULL;
    #define CREATE_stream_KW_ON  if (stream_KW_ON == NULL) {stream_KW_ON = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_ON"); } 
    stream_RPAREN   = NULL;
    #define CREATE_stream_RPAREN  if (stream_RPAREN == NULL) {stream_RPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token RPAREN"); } 
    stream_KW_SIZE   = NULL;
    #define CREATE_stream_KW_SIZE  if (stream_KW_SIZE == NULL) {stream_KW_SIZE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_SIZE"); } 
    stream_schemaList   = NULL;
    #define CREATE_stream_schemaList  if (stream_schemaList == NULL) {stream_schemaList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule schemaList"); }
    stream_streamType   = NULL;
    #define CREATE_stream_streamType  if (stream_streamType == NULL) {stream_streamType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule streamType"); }

    retval.tree  = NULL;

    {
        {
            //  ./StreamSQL.g:87:5: ( KW_CREATE KW_SCHEMA Identifier schemaList -> ^( TOK_CREATE_SCHEMA Identifier schemaList ) | KW_CREATE streamType KW_STREAM streamName= Identifier schemaName= Identifier -> ^( TOK_CREATE_STREAM streamType $streamName $schemaName) | KW_CREATE KW_WINDOW windowName= Identifier LPAREN KW_SIZE Number KW_ADVANCE Number KW_ON onWhat= Identifier RPAREN -> ^( TOK_CREATE_WINDOW $windowName Number Number $onWhat) )

            ANTLR3_UINT32 alt4;

            alt4=3;

            switch ( LA(1) )
            {
            case KW_CREATE:
            	{
            		switch ( LA(2) )
            		{
            		case KW_SCHEMA:
            			{
            				alt4=1;
            			}
            		    break;
            		case KW_WINDOW:
            			{
            				alt4=3;
            			}
            		    break;
            		case KW_INPUT:
            		case KW_OUTPUT:
            			{
            				alt4=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 4;
            		    EXCEPTION->state        = 1;


            		    goto rulecreateStatementEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto rulecreateStatementEx;

            }

            switch (alt4)
            {
        	case 1:
        	    // ./StreamSQL.g:87:7: KW_CREATE KW_SCHEMA Identifier schemaList
        	    {
        	        KW_CREATE22 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_CREATE, &FOLLOW_KW_CREATE_in_createStatement401);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_CREATE; stream_KW_CREATE->add(stream_KW_CREATE, KW_CREATE22, NULL);


        	        KW_SCHEMA23 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_SCHEMA, &FOLLOW_KW_SCHEMA_in_createStatement403);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_SCHEMA; stream_KW_SCHEMA->add(stream_KW_SCHEMA, KW_SCHEMA23, NULL);


        	        Identifier24 = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_createStatement405);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, Identifier24, NULL);


        	        FOLLOWPUSH(FOLLOW_schemaList_in_createStatement407);
        	        schemaList25=schemaList(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }

        	        CREATE_stream_schemaList; stream_schemaList->add(stream_schemaList, schemaList25.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : schemaList, Identifier
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 89:8: -> ^( TOK_CREATE_SCHEMA Identifier schemaList )
        	        	{
        	        	    // ./StreamSQL.g:89:11: ^( TOK_CREATE_SCHEMA Identifier schemaList )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_CREATE_SCHEMA, (pANTLR3_UINT8)"TOK_CREATE_SCHEMA")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_Identifier == NULL ? NULL : stream_Identifier->nextNode(stream_Identifier)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_schemaList == NULL ? NULL : stream_schemaList->nextTree(stream_schemaList));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // ./StreamSQL.g:91:7: KW_CREATE streamType KW_STREAM streamName= Identifier schemaName= Identifier
        	    {
        	        KW_CREATE26 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_CREATE, &FOLLOW_KW_CREATE_in_createStatement439);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_CREATE; stream_KW_CREATE->add(stream_KW_CREATE, KW_CREATE26, NULL);


        	        FOLLOWPUSH(FOLLOW_streamType_in_createStatement441);
        	        streamType27=streamType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }

        	        CREATE_stream_streamType; stream_streamType->add(stream_streamType, streamType27.tree, NULL);

        	        KW_STREAM28 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_STREAM, &FOLLOW_KW_STREAM_in_createStatement443);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_STREAM; stream_KW_STREAM->add(stream_KW_STREAM, KW_STREAM28, NULL);


        	        streamName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_createStatement447);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, streamName, NULL);


        	        schemaName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_createStatement451);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, schemaName, NULL);


        	        /* AST REWRITE
        	         * elements          : streamType, streamName, schemaName
        	         * token labels      : schemaName, streamName
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_schemaName;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_streamName;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_schemaName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token schemaName", schemaName);
        	        	stream_streamName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token streamName", streamName);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 93:8: -> ^( TOK_CREATE_STREAM streamType $streamName $schemaName)
        	        	{
        	        	    // ./StreamSQL.g:93:11: ^( TOK_CREATE_STREAM streamType $streamName $schemaName)
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_CREATE_STREAM, (pANTLR3_UINT8)"TOK_CREATE_STREAM")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_streamType == NULL ? NULL : stream_streamType->nextTree(stream_streamType));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_streamName == NULL ? NULL : stream_streamName->nextNode(stream_streamName));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_schemaName == NULL ? NULL : stream_schemaName->nextNode(stream_schemaName));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_schemaName != NULL) stream_schemaName->free(stream_schemaName); 
        	        	if (stream_streamName != NULL) stream_streamName->free(stream_streamName); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 3:
        	    // ./StreamSQL.g:95:7: KW_CREATE KW_WINDOW windowName= Identifier LPAREN KW_SIZE Number KW_ADVANCE Number KW_ON onWhat= Identifier RPAREN
        	    {
        	        KW_CREATE29 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_CREATE, &FOLLOW_KW_CREATE_in_createStatement482);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_CREATE; stream_KW_CREATE->add(stream_KW_CREATE, KW_CREATE29, NULL);


        	        KW_WINDOW30 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_WINDOW, &FOLLOW_KW_WINDOW_in_createStatement484);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_WINDOW; stream_KW_WINDOW->add(stream_KW_WINDOW, KW_WINDOW30, NULL);


        	        windowName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_createStatement496);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, windowName, NULL);


        	        LPAREN31 = (pANTLR3_COMMON_TOKEN) MATCHT(LPAREN, &FOLLOW_LPAREN_in_createStatement498);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_LPAREN; stream_LPAREN->add(stream_LPAREN, LPAREN31, NULL);


        	        KW_SIZE32 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_SIZE, &FOLLOW_KW_SIZE_in_createStatement500);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_SIZE; stream_KW_SIZE->add(stream_KW_SIZE, KW_SIZE32, NULL);


        	        Number33 = (pANTLR3_COMMON_TOKEN) MATCHT(Number, &FOLLOW_Number_in_createStatement502);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Number; stream_Number->add(stream_Number, Number33, NULL);


        	        KW_ADVANCE34 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_ADVANCE, &FOLLOW_KW_ADVANCE_in_createStatement504);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_ADVANCE; stream_KW_ADVANCE->add(stream_KW_ADVANCE, KW_ADVANCE34, NULL);


        	        Number35 = (pANTLR3_COMMON_TOKEN) MATCHT(Number, &FOLLOW_Number_in_createStatement506);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Number; stream_Number->add(stream_Number, Number35, NULL);


        	        KW_ON36 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_ON, &FOLLOW_KW_ON_in_createStatement508);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_ON; stream_KW_ON->add(stream_KW_ON, KW_ON36, NULL);


        	        onWhat = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_createStatement512);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, onWhat, NULL);


        	        RPAREN37 = (pANTLR3_COMMON_TOKEN) MATCHT(RPAREN, &FOLLOW_RPAREN_in_createStatement514);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_RPAREN; stream_RPAREN->add(stream_RPAREN, RPAREN37, NULL);


        	        /* AST REWRITE
        	         * elements          : onWhat, windowName, Number, Number
        	         * token labels      : onWhat, windowName
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_onWhat;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_windowName;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_onWhat=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token onWhat", onWhat);
        	        	stream_windowName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token windowName", windowName);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 99:8: -> ^( TOK_CREATE_WINDOW $windowName Number Number $onWhat)
        	        	{
        	        	    // ./StreamSQL.g:99:11: ^( TOK_CREATE_WINDOW $windowName Number Number $onWhat)
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_CREATE_WINDOW, (pANTLR3_UINT8)"TOK_CREATE_WINDOW")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_windowName == NULL ? NULL : stream_windowName->nextNode(stream_windowName));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_Number == NULL ? NULL : stream_Number->nextNode(stream_Number)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_Number == NULL ? NULL : stream_Number->nextNode(stream_Number)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_onWhat == NULL ? NULL : stream_onWhat->nextNode(stream_onWhat));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_onWhat != NULL) stream_onWhat->free(stream_onWhat); 
        	        	if (stream_windowName != NULL) stream_windowName->free(stream_windowName); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecreateStatementEx; /* Prevent compiler warnings */
    rulecreateStatementEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_KW_ADVANCE != NULL) stream_KW_ADVANCE->free(stream_KW_ADVANCE);
        if (stream_KW_SCHEMA != NULL) stream_KW_SCHEMA->free(stream_KW_SCHEMA);
        if (stream_KW_WINDOW != NULL) stream_KW_WINDOW->free(stream_KW_WINDOW);
        if (stream_Identifier != NULL) stream_Identifier->free(stream_Identifier);
        if (stream_KW_CREATE != NULL) stream_KW_CREATE->free(stream_KW_CREATE);
        if (stream_Number != NULL) stream_Number->free(stream_Number);
        if (stream_KW_STREAM != NULL) stream_KW_STREAM->free(stream_KW_STREAM);
        if (stream_LPAREN != NULL) stream_LPAREN->free(stream_LPAREN);
        if (stream_KW_ON != NULL) stream_KW_ON->free(stream_KW_ON);
        if (stream_RPAREN != NULL) stream_RPAREN->free(stream_RPAREN);
        if (stream_KW_SIZE != NULL) stream_KW_SIZE->free(stream_KW_SIZE);
        if (stream_schemaList != NULL) stream_schemaList->free(stream_schemaList);
        if (stream_streamType != NULL) stream_streamType->free(stream_streamType);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end createStatement */

/**
 * $ANTLR start schemaList
 * ./StreamSQL.g:103:1: schemaList : LPAREN columnNameType ( COMMA columnNameType )* RPAREN -> ^( TOK_SCHEMA_LIST ( columnNameType )+ ) ;
 */
static StreamSQLParser_schemaList_return
schemaList(pStreamSQLParser ctx)
{
    StreamSQLParser_schemaList_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    LPAREN38;
    pANTLR3_COMMON_TOKEN    COMMA40;
    pANTLR3_COMMON_TOKEN    RPAREN42;
    StreamSQLParser_columnNameType_return columnNameType39;
    #undef	RETURN_TYPE_columnNameType39
    #define	RETURN_TYPE_columnNameType39 StreamSQLParser_columnNameType_return

    StreamSQLParser_columnNameType_return columnNameType41;
    #undef	RETURN_TYPE_columnNameType41
    #define	RETURN_TYPE_columnNameType41 StreamSQLParser_columnNameType_return

    pANTLR3_BASE_TREE LPAREN38_tree;
    pANTLR3_BASE_TREE COMMA40_tree;
    pANTLR3_BASE_TREE RPAREN42_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_COMMA;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LPAREN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_RPAREN;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_columnNameType;
    /* Initialize rule variables
     */

    root_0 = NULL;

    LPAREN38       = NULL;
    COMMA40       = NULL;
    RPAREN42       = NULL;
    columnNameType39.tree = NULL;

    columnNameType41.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    LPAREN38_tree   = NULL;
    COMMA40_tree   = NULL;
    RPAREN42_tree   = NULL;

    stream_COMMA   = NULL;
    #define CREATE_stream_COMMA  if (stream_COMMA == NULL) {stream_COMMA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token COMMA"); } 
    stream_LPAREN   = NULL;
    #define CREATE_stream_LPAREN  if (stream_LPAREN == NULL) {stream_LPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LPAREN"); } 
    stream_RPAREN   = NULL;
    #define CREATE_stream_RPAREN  if (stream_RPAREN == NULL) {stream_RPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token RPAREN"); } 
    stream_columnNameType   = NULL;
    #define CREATE_stream_columnNameType  if (stream_columnNameType == NULL) {stream_columnNameType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule columnNameType"); }

    retval.tree  = NULL;

    {
        // ./StreamSQL.g:105:5: ( LPAREN columnNameType ( COMMA columnNameType )* RPAREN -> ^( TOK_SCHEMA_LIST ( columnNameType )+ ) )
        // ./StreamSQL.g:105:7: LPAREN columnNameType ( COMMA columnNameType )* RPAREN
        {
            LPAREN38 = (pANTLR3_COMMON_TOKEN) MATCHT(LPAREN, &FOLLOW_LPAREN_in_schemaList557);
            if  (HASEXCEPTION())
            {
                goto ruleschemaListEx;
            }
             
            CREATE_stream_LPAREN; stream_LPAREN->add(stream_LPAREN, LPAREN38, NULL);


            FOLLOWPUSH(FOLLOW_columnNameType_in_schemaList559);
            columnNameType39=columnNameType(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleschemaListEx;
            }

            CREATE_stream_columnNameType; stream_columnNameType->add(stream_columnNameType, columnNameType39.tree, NULL);

            // ./StreamSQL.g:105:29: ( COMMA columnNameType )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5)
                {
            	case 1:
            	    // ./StreamSQL.g:105:30: COMMA columnNameType
            	    {
            	        COMMA40 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_schemaList562);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleschemaListEx;
            	        }
            	         
            	        CREATE_stream_COMMA; stream_COMMA->add(stream_COMMA, COMMA40, NULL);


            	        FOLLOWPUSH(FOLLOW_columnNameType_in_schemaList564);
            	        columnNameType41=columnNameType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleschemaListEx;
            	        }

            	        CREATE_stream_columnNameType; stream_columnNameType->add(stream_columnNameType, columnNameType41.tree, NULL);

            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


            RPAREN42 = (pANTLR3_COMMON_TOKEN) MATCHT(RPAREN, &FOLLOW_RPAREN_in_schemaList568);
            if  (HASEXCEPTION())
            {
                goto ruleschemaListEx;
            }
             
            CREATE_stream_RPAREN; stream_RPAREN->add(stream_RPAREN, RPAREN42, NULL);


            /* AST REWRITE
             * elements          : columnNameType
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 107:8: -> ^( TOK_SCHEMA_LIST ( columnNameType )+ )
            	{
            	    // ./StreamSQL.g:107:11: ^( TOK_SCHEMA_LIST ( columnNameType )+ )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_SCHEMA_LIST, (pANTLR3_UINT8)"TOK_SCHEMA_LIST")
            	        , root_1));

            	        if ((stream_columnNameType == NULL || !stream_columnNameType->hasNext(stream_columnNameType))  )
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
            	        }
            	        else
            	        {
            	        	while ( (stream_columnNameType->hasNext(stream_columnNameType))  ) {
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_columnNameType == NULL ? NULL : stream_columnNameType->nextTree(stream_columnNameType));

            	        	}
            	        	stream_columnNameType->reset(stream_columnNameType);

            	        }
            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleschemaListEx; /* Prevent compiler warnings */
    ruleschemaListEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_COMMA != NULL) stream_COMMA->free(stream_COMMA);
        if (stream_LPAREN != NULL) stream_LPAREN->free(stream_LPAREN);
        if (stream_RPAREN != NULL) stream_RPAREN->free(stream_RPAREN);
        if (stream_columnNameType != NULL) stream_columnNameType->free(stream_columnNameType);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end schemaList */

/**
 * $ANTLR start streamType
 * ./StreamSQL.g:111:1: streamType : ( KW_INPUT | KW_OUTPUT ) ;
 */
static StreamSQLParser_streamType_return
streamType(pStreamSQLParser ctx)
{
    StreamSQLParser_streamType_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set43;

    pANTLR3_BASE_TREE set43_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set43       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set43_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./StreamSQL.g:113:5: ( ( KW_INPUT | KW_OUTPUT ) )
        // ./StreamSQL.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set43=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == KW_INPUT || LA(1) == KW_OUTPUT )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set43))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulestreamTypeEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulestreamTypeEx; /* Prevent compiler warnings */
    rulestreamTypeEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end streamType */

/**
 * $ANTLR start columnNameType
 * ./StreamSQL.g:117:1: columnNameType : coluName= Identifier dataType -> ^( TOK_NAME_TYPE $coluName dataType ) ;
 */
static StreamSQLParser_columnNameType_return
columnNameType(pStreamSQLParser ctx)
{
    StreamSQLParser_columnNameType_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    coluName;
    StreamSQLParser_dataType_return dataType44;
    #undef	RETURN_TYPE_dataType44
    #define	RETURN_TYPE_dataType44 StreamSQLParser_dataType_return

    pANTLR3_BASE_TREE coluName_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Identifier;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_dataType;
    /* Initialize rule variables
     */

    root_0 = NULL;

    coluName       = NULL;
    dataType44.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    coluName_tree   = NULL;

    stream_Identifier   = NULL;
    #define CREATE_stream_Identifier  if (stream_Identifier == NULL) {stream_Identifier = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Identifier"); } 
    stream_dataType   = NULL;
    #define CREATE_stream_dataType  if (stream_dataType == NULL) {stream_dataType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule dataType"); }

    retval.tree  = NULL;

    {
        // ./StreamSQL.g:119:5: (coluName= Identifier dataType -> ^( TOK_NAME_TYPE $coluName dataType ) )
        // ./StreamSQL.g:119:7: coluName= Identifier dataType
        {
            coluName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_columnNameType631);
            if  (HASEXCEPTION())
            {
                goto rulecolumnNameTypeEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, coluName, NULL);


            FOLLOWPUSH(FOLLOW_dataType_in_columnNameType633);
            dataType44=dataType(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecolumnNameTypeEx;
            }

            CREATE_stream_dataType; stream_dataType->add(stream_dataType, dataType44.tree, NULL);

            /* AST REWRITE
             * elements          : coluName, dataType
             * token labels      : coluName
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_coluName;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_coluName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token coluName", coluName);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 121:8: -> ^( TOK_NAME_TYPE $coluName dataType )
            	{
            	    // ./StreamSQL.g:121:11: ^( TOK_NAME_TYPE $coluName dataType )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_NAME_TYPE, (pANTLR3_UINT8)"TOK_NAME_TYPE")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_coluName == NULL ? NULL : stream_coluName->nextNode(stream_coluName));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_dataType == NULL ? NULL : stream_dataType->nextTree(stream_dataType));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_coluName != NULL) stream_coluName->free(stream_coluName); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulecolumnNameTypeEx; /* Prevent compiler warnings */
    rulecolumnNameTypeEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_Identifier != NULL) stream_Identifier->free(stream_Identifier);
        if (stream_dataType != NULL) stream_dataType->free(stream_dataType);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end columnNameType */

/**
 * $ANTLR start dataType
 * ./StreamSQL.g:125:1: dataType : ( KW_INT | KW_DOUBLE );
 */
static StreamSQLParser_dataType_return
dataType(pStreamSQLParser ctx)
{
    StreamSQLParser_dataType_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set45;

    pANTLR3_BASE_TREE set45_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set45       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set45_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./StreamSQL.g:127:5: ( KW_INT | KW_DOUBLE )
        // ./StreamSQL.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set45=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == KW_DOUBLE || LA(1) == KW_INT )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set45))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruledataTypeEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledataTypeEx; /* Prevent compiler warnings */
    ruledataTypeEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end dataType */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
